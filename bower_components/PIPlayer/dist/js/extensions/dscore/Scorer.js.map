{"version":3,"file":"Scorer.js","sources":["computeD.js","msgMan.js","parcelMng.js","Scorer.js"],"names":[],"mappings":"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","sourcesContent":["\r\ndefine('extensions/dscore/computeD',['jquery'],function($){\r\n\r\n\r\n\r\n\t\tvar computeD = {\r\n\r\n\t\t\tdataArray : {}, //The data array or structure the PIP will provide\r\n\t\t\tAnalyzedVar : \"latency\", //The main variable used for the score computation. Usually will be the latency.\r\n\t\t\tErrorVar : \"error\", //The variable that indicates whether there was an error in the response\r\n\t\t\tcondVar:\"\",  //The name of the variable that will store the variables\r\n\t\t\tcond1VarValues: [], //An array with the values of the condVar that will comprise of condition 1 in the comparison\r\n\t\t\tcond2VarValues: [], //An array with the values of the condVar that will comprise of condition 2 in the comparison\r\n\t\t\tparcelVar : \"\",\r\n\t\t\tparcelValue : [],\r\n\t\t\tfastRT : 300, //Below this reaction time, the latency is considered extremely fast.\r\n\t\t\tmaxFastTrialsRate : 0.1, //Above this % of extremely fast responses within a condition, the participant is considered too fast.\r\n\t\t\tminRT : 400, //Below this latency\r\n\t\t\tmaxRT : 10000, //above this\r\n\t\t\tmaxErrorParcelRate: 0.4,\r\n\t\t\terrorLatency : {use:\"latency\", penalty:600, useForSTD:true},\r\n\t\t\tpostSettings : {}\r\n\t\t\t//ignoreErr : false, //if this is true then if error per\r\n\t\t\t//userErrLatency : true, //if this is true then consider only trials that are between minRT  and maxRT\r\n\t\t\t//useErrSTD : true,//?\r\n\r\n\t\t};\r\n\r\n\t\t$.extend(computeD, {\r\n\r\n\t\t\tsetComputeObject: function(obj){\r\n\t\t\t\t$.extend(this,obj);\r\n\t\t\t},\r\n\r\n\t\t\tsetDataArray: function(){\r\n\t\t\t\t// use the real global in order to preven problems with dependencies\r\n\t\t\t\tvar global = window.piGlobal;\r\n\r\n\t\t\t\tthis.dataArray = global.current.logs;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\treturn computeD;\r\n\r\n\r\n});\n","define('extensions/dscore/msgMan',['jquery','underscore'],function($,_){\r\n\r\n\tvar messages = {\r\n\t\tMessageDef:[],\r\n\t\tmanyErrors: \"There were too many errors made to determine a result.\",\r\n\t\ttooFast: \"There were too many fast trials to determine a result.\",\r\n\t\tnotEnough: \"There were not enough trials to determine a result.\"\r\n\t};\r\n\r\n\tvar msgMan = {\r\n\t\tsetMsgObject: function(Obj){\r\n\t\t\t$.extend(messages,Obj);\r\n\t\t},\r\n\r\n\t\tgetScoreMsg: function(score){\r\n\r\n\t\t\tvar array = messages.MessageDef;\r\n\t\t\tif (!array || !array.length){\r\n\t\t\t\tthrow new Error('You must define a \"MessageDef\" array.');\r\n\t\t\t}\r\n\r\n\t\t\tvar scoreNum = parseFloat(score);\r\n\t\t\tvar cut = null;\r\n\t\t\tvar msg = null;\r\n\t\t\tvar rightMsg = 'error: msg was not set';\r\n\t\t\tvar set = false;\r\n\r\n\t\t\t// @TODO repleace this whole section with a \"_.find()\" or something.\r\n\t\t\t_.each(array, function(val) {\r\n\t\t\t\tcut = parseFloat(val.cut);\r\n\t\t\t\tmsg = val.message;\r\n\t\t\t\tif (scoreNum<=cut && !set){\r\n\t\t\t\t\trightMsg = msg;\r\n\t\t\t\t\tset = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (!set){\r\n\t\t\t\tvar length = array.length;\r\n\t\t\t\tvar obj = array[length-1];\r\n\t\t\t\trightMsg = obj.message;\r\n\t\t\t}\r\n\t\t\treturn rightMsg;\r\n\t\t},\r\n\r\n\t\tgetMessage: function getMessage(type){\r\n\t\t\treturn messages[type];\r\n\t\t}\r\n\t};\r\n\r\n\treturn msgMan;\r\n});\n","define('extensions/dscore/parcelMng',['jquery','underscore','./msgMan'],function($,_, msgMan){\r\n\r\n\tvar parcelMng= {};\r\n\r\n\r\n\t$.extend(parcelMng, {\r\n\r\n\t\tparcelArray: [], // Holds parcel array\r\n\t\tscoreData: {},\t// Holds score and error message\r\n\r\n/*  Method: Void Init\r\n\tInput: Uses logs from API\r\n\tOutput: Sets parcelArray with array of type parcel\r\n\tDescription: Init goes over the log and creates an array of object of type Parcel according to\r\n\tthe parcelValue array in computeD. Each parcel object holds relevant information regarding the\r\n\tparcel including an array of trials with the relevant parcel name.\r\n\r\n\r\n*/\r\n\t\tInit: function(compute){\r\n\t\t\t// use the real global in order to preven problems with dependencies\r\n\t\t\tvar global = window.piGlobal;\r\n\r\n\t\t\tvar data = global.current.logs;\r\n\t\t\tparcelMng.parcelArray = [];\r\n\t\t\tparcelMng.scoreData = {};\r\n\r\n\t\t\t// get settings\r\n\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\r\n\t\t\tvar error = compute.ErrorVar;\r\n\t\t\tvar parcelVar = compute.parcelVar;\r\n\t\t\tvar parcels = compute.parcelValue;\r\n\t\t\tvar min = compute.minRT;\r\n\t\t\tvar max = compute.maxRT;\r\n\t\t\tvar fastRT= compute.fastRT;\r\n\r\n\t\t\t// set counters\r\n\t\t\tvar totalScoredTrials = 0;\r\n\t\t\tvar trialsUnder = 0;\r\n\t\t\tvar totalTrials=0;\r\n\t\t\tvar totalErrorTrials =0;\r\n\t\t\tvar maxFastTrialsRate = parseFloat(compute.maxFastTrialsRate);\r\n\r\n\r\n\t\t\tif (typeof parcels == 'undefined' || parcels.length === 0){\r\n\t\t\t\ttotalTrials =0;\r\n\t\t\t\ttotalScoredTrials=0;\r\n\t\t\t\ttrialsUnder=0;\r\n\t\t\t\ttotalErrorTrials=0;\r\n\t\t\t\tvar p = {};\r\n\t\t\t\tp.name = 'general';\r\n\t\t\t\tp.trialIData = [];\r\n\t\t\t\t_.each (data, function (value) {// loop per object in logger\r\n\t\t\t\t\t\tif (value[AnalyzedVar]>=min && value[AnalyzedVar]<=max){\r\n\t\t\t\t\t\t\ttotalTrials++;\r\n\t\t\t\t\t\t\tif (value.data[error] == 1) {\r\n\t\t\t\t\t\t\t\ttotalErrorTrials++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//p.trialIData.push(value);//push all data\r\n\t\t\t\t\t\t\t//totalScoredTrials++;\r\n\t\t\t\t\t\t\tif (parcelMng.validate(p,value,compute)) {\r\n\t\t\t\t\t\t\t\ttotalScoredTrials++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else {\r\n\t\t\t\t\t\t\tif (value[AnalyzedVar]<= fastRT) {\r\n\t\t\t\t\t\t\t\ttrialsUnder++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tparcelMng.checkErrors(totalTrials,totalErrorTrials,compute);\r\n\t\t\t\tparcelMng.parcelArray[0] = p;\r\n\t\t\t} else {\r\n\t\t\t\t_.each (parcels, function(parcelName,index) {// per parcel from parcelValue\r\n\t\t\t\t\t//set variables calculated per parcel\r\n\t\t\t\t\ttotalTrials =0;\r\n\t\t\t\t\ttotalScoredTrials=0;\r\n\t\t\t\t\ttrialsUnder=0;\r\n\t\t\t\t\ttotalErrorTrials=0;\r\n\t\t\t\t\tvar p = {};\r\n\t\t\t\t\tp.name = parcelName;\r\n\t\t\t\t\tp.trialIData = [];\r\n\t\t\t\t\t///////////////////////////////////\r\n\t\t\t\t\t_.each (data, function (value) {//loop per object in logger\r\n\t\t\t\t\t\tvar trialParcelName = value.data[parcelVar];\r\n\r\n\t\t\t\t\t\t// if this trial belongs to parcel\r\n\t\t\t\t\t\tif (trialParcelName == parcelName){\r\n\t\t\t\t\t\t\tif (value[AnalyzedVar]>=min && value[AnalyzedVar]<=max){\r\n\t\t\t\t\t\t\t\ttotalTrials++;\r\n\t\t\t\t\t\t\t\tif (value.data[error] == 1) {\r\n\t\t\t\t\t\t\t\t\ttotalErrorTrials++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t//p.trialIData.push(value);//push all data\r\n\t\t\t\t\t\t\t\t//totalScoredTrials++;\r\n\t\t\t\t\t\t\t\tif (parcelMng.validate(p,value,compute)) {\r\n\t\t\t\t\t\t\t\t\ttotalScoredTrials++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}else {\r\n\t\t\t\t\t\t\t\tif (value[AnalyzedVar]<= fastRT) {\r\n\t\t\t\t\t\t\t\t\ttrialsUnder++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t});\r\n\t\t\t\t\tparcelMng.checkErrors(totalTrials,totalErrorTrials,compute);//apply maxErrorParcelRate logic\r\n\t\t\t\t\tparcelMng.parcelArray[index] = p;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif ( (trialsUnder/totalScoredTrials) > maxFastTrialsRate){\r\n\t\t\t\tparcelMng.scoreData.errorMessage = msgMan.getMessage('tooFast');\r\n\r\n\t\t\t}\r\n\r\n\t\t//\tconsole.log('finished init the parcelArray is:');\r\n\t\t//\tconsole.log(parcelMng.parcelArray);\r\n\t\t//\tconsole.log('--------------------');\r\n\t\t},\r\n\r\n/*  Method: Void checkErrors\r\n\tInput: totalTrials,totalErrorTrials and compute object.\r\n\tOutput: Sets scoreData with error message if relevant.\r\n\tDescription: Helper method to check for errors according to maxErrorParcelRate from compute object.\r\n\tsets an error message in scoreData.\r\n\r\n*/\r\n\t\tcheckErrors: function(totalTrials,totalErrorTrials,compute){\r\n\r\n\t\t\tvar maxErrorParcelRate = compute.maxErrorParcelRate;\r\n\t\t\tif (totalErrorTrials/totalTrials > maxErrorParcelRate){\r\n\t\t\t\tparcelMng.scoreData.errorMessage = msgMan.getMessage('manyErrors');\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n/* Function: Void validate.\r\n\tInput: parcel object, trial object from the log and the compute object.\r\n\tOutput: Pushes the trial to the parcel based on information from errorLatency. Returns true/false.\r\n\tDescription: Helper method to apply errorLatency logic. If set to 'latency' trials witch are error\r\n\twould be added to the parcel trial array. if set to false trials that are error would not be added,\r\n\tif set to panelty error trials will be added and later panelized.\r\n\r\n*/\r\n\r\n\t\tvalidate: function(p,value,compute){\r\n\t\t\tvar errorLatency = compute.errorLatency;\r\n\t\t\tvar error = compute.ErrorVar;\r\n\t\t\tvar data = value.data;\r\n\r\n\r\n\t\t\tif (errorLatency.use =='latency'){\r\n\t\t\t\tp.trialIData.push(value);\r\n\t\t\t\treturn true;\r\n\t\t\t}else{\r\n\t\t\t\tif (errorLatency.use =='false'){\r\n\t\t\t\t\tif(data[error]=='1'){\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tp.trialIData.push(value);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(errorLatency.use =='penalty'){\r\n\t\t\t\t\tp.trialIData.push(value);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t},\r\n\r\n/*  Function: Void addPenalty.\r\n\tInput: parcel object and the compute object.\r\n\tOutput: adds penalty to latency of trials\r\n\tDescription: Helper method to add average and penalty to error trials\r\n\tif errorLatency is set to 'penalty'. Should be called after avgAll.\r\n\r\n*/\r\n\r\n\t\taddPenalty: function(p,compute){\r\n\t\t\tvar errorLatency = compute.errorLatency;\r\n\r\n\r\n\t\t\tif (errorLatency.use == 'penalty'){\r\n\t\t\t\tvar penalty = parseFloat(errorLatency.penalty);\r\n\t\t\t\tvar ErrorVar = compute.ErrorVar;\r\n\t\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\r\n\t\t\t\tvar condVar = compute.condVar;\r\n\t\t\t\tvar cond1 = compute.cond1VarValues;\r\n\t\t\t\tvar cond2 = compute.cond2VarValues;\r\n\t\t\t\tvar trialIData = p.trialIData;\r\n\t\t\t\tvar avg1 = p.avgCon1;\r\n\t\t\t\tvar avg2 = p.avgCon2;\r\n\r\n\r\n\t\t\t\t_.each (trialIData, function (value) {\r\n\t\t\t\t\tvar data = value.data;\r\n\t\t\t\t\tvar error = data[ErrorVar];\r\n\t\t\t\t\tvar dataCond = data[condVar];\r\n\t\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\r\n\t\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\r\n\r\n\t\t\t\t\tif (error=='1'){\r\n\t\t\t\t\t\tif (diff1){\r\n\t\t\t\t\t\t\tvalue[AnalyzedVar] += avg1+ penalty;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif (diff2){\r\n\t\t\t\t\t\t\t\tvalue[AnalyzedVar] += avg2+ penalty;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t}\r\n\t\t},\r\n\r\n/*  Function: Void avgAll.\r\n\tInput: compute object.\r\n\tOutput: setting avgCon1 and avgCon2\r\n\tDescription: Loop over the parcels and Set average for condition 1 trials and for condition 2 trials.\r\n\r\n*/\r\n\r\n\t\tavgAll: function(compute){\r\n\t\t\t_.each(parcelMng.parcelArray, function (value) {\r\n\t\t\t\tparcelMng.avgParcel(value,compute);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\r\n/*  Function: Void avgParcel.\r\n\tInput: compute object, parcel.\r\n\tOutput: setting avgCon1 and avgCon2 in parcel.\r\n\tDescription: Set average for condition 1 trials and for condition 2 trials in the parcel.\r\n\r\n*/\r\n\r\n\t\tavgParcel: function(p,compute){\r\n\t\t\tvar trialIData = p.trialIData;\r\n\t\t\tvar condVar = compute.condVar;\r\n\t\t\tvar cond1 = compute.cond1VarValues;\r\n\t\t\tvar cond2 = compute.cond2VarValues;\r\n\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\r\n\t\t\tvar avgCon1 = 0;\r\n\t\t\tvar avgCon2 = 0;\r\n\t\t\tvar avgBoth = 0;\r\n\t\t\tvar numCond1 = 0;\r\n\t\t\tvar numCond2 = 0;\r\n\t\t\tvar numBoth = 0;\r\n\r\n\t\t\t_.each (trialIData, function (value) {\r\n\r\n\t\t\t\tvar AnVar = value[AnalyzedVar];\r\n\t\t\t\tvar data = value.data;\r\n\t\t\t\tavgBoth += AnVar;\r\n\t\t\t\tnumBoth ++;\r\n\t\t\t\t//var diff1 = ( _(data[condVar]).difference(cond1) );\r\n\t\t\t\t//var diff2 = ( _(data[condVar]).difference(cond2) );\r\n\t\t\t\tvar dataCond = data[condVar];\r\n\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\r\n\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\r\n\r\n\t\t\t\tif (diff1) {\r\n\t\t\t\t\tnumCond1++;\r\n\t\t\t\t\tavgCon1 += AnVar;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (diff2){\r\n\t\t\t\t\t\tnumCond2++;\r\n\t\t\t\t\t\tavgCon2 += AnVar;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\t\t\tif (numCond1 <= 2 || numCond2 <= 2){\r\n\t\t\t\tparcelMng.scoreData.errorMessage = msgMan.getMessage(\"notEnough\");\r\n\t\t\t}\r\n\t\t\tif (numCond1 !== 0) {\r\n\t\t\t\tavgCon1 = avgCon1/numCond1;\r\n\t\t\t}\r\n\t\t\tif (numCond2 !== 0) {\r\n\t\t\t\tavgCon2 = avgCon2/numCond2;\r\n\t\t\t}\r\n\t\t\tp.avgCon1 = avgCon1;\r\n\t\t\tp.avgCon2 = avgCon2;\r\n\t\t\tp.diff = p.avgCon1 - p.avgCon2;\r\n\t\t\tif (numBoth !== 0) {\r\n\t\t\t\tp.avgBoth = avgBoth/numBoth;\r\n\t\t\t}\r\n\t\t\tparcelMng.addPenalty(p,compute);\r\n\t\t},\r\n\r\n/*  Function: Void checkArray.\r\n\tInput: the condition from the trial and an array of condition from computeD object.\r\n\tOutput: return true if condition is in the array.\r\n\tDescription: Helper function that returns true if condition is in the array or false otherwise.\r\n\r\n*/\r\n\r\n\t\tcheckArray: function(conFromData,con){\r\n\r\n\t\t\tfor(var i=0; i<con.length; i++){\r\n\t\t\t\tvar condition = con[i];\r\n\t\t\t\tif (condition == conFromData ){\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t\t\t// var res;\r\n\r\n\t\t\t// res = _.find(con,function(conFromData){\r\n\t\t\t// return true;\r\n\r\n\t\t\t// });\r\n\t\t\t// return res==conFromData;\r\n\r\n\t\t},\r\n\r\n/*  Function: Void varianceAll.\r\n\tInput: compute object, parcel.\r\n\tOutput: variance variable in parcel.\r\n\tDescription: Loop over the parcels and set the variance variable.\r\n\r\n*/\r\n\r\n\t\tvarianceAll: function(compute){\r\n\t\t\t_.each (parcelMng.parcelArray, function (value) {\r\n\t\t\t\tparcelMng.varianceParcel(value,compute);\r\n\t\t\t});\r\n\t\t},\r\n\r\n/*  Function: Void varianceParcel.\r\n\tInput: compute object, parcel.\r\n\tOutput: setting variance variable in parcel.\r\n\tDescription: goes over the trials of the parcel and calculate variance.\r\n\r\n*/\r\n\t\tvarianceParcel: function(p,compute){\r\n\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\r\n\t\t\tvar trialIData = p.trialIData;\r\n\t\t\tvar cond1 = compute.cond1VarValues;\r\n\t\t\tvar cond2 = compute.cond2VarValues;\r\n\t\t\tvar condVar = compute.condVar;\r\n\t\t\tvar avg = p.avgBoth;\r\n\t\t\tvar d = 0;\r\n\t\t\tvar x2 = 0;\r\n\t\t\tvar pooledCond1 = [];\r\n\t\t\tvar pooledCond2 = [];\r\n\t\t\tvar pooledData = [];\r\n\t\t\tvar errorLatency = compute.errorLatency;\r\n\t\t\tvar useForSTD = errorLatency.useForSTD;\r\n\r\n\r\n\t\t\t_.each (trialIData, function (value) {//pool to one array\r\n\t\t\t\tvar data = value.data;\r\n\t\t\t\tvar AnVar = value[AnalyzedVar];\r\n\t\t\t\tvar ErrorVar = compute.ErrorVar;\r\n\t\t\t\tvar error = data[ErrorVar];\r\n\t\t\t\tvar dataCond = data[condVar];\r\n\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\r\n\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\r\n\t\t\t\t//var diff1 = ( _(data[condVar]).difference(cond1) );\r\n\t\t\t\t//var diff2 = ( _(data[condVar]).difference(cond2) );\r\n\t\t\t\tif (diff1) {\r\n\t\t\t\t\tif (useForSTD){\r\n\t\t\t\t\t\tpooledCond1.push(AnVar);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tif (error=='0') {\r\n\t\t\t\t\t\t\tpooledCond1.push(AnVar);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (diff2){\r\n\t\t\t\t\t\tif (useForSTD){\r\n\t\t\t\t\t\t\tpooledCond2.push(AnVar);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tif (error=='0') {\r\n\t\t\t\t\t\t\t\tpooledCond1.push(AnVar);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t});\r\n\r\n\t\t\tpooledData = pooledCond1.concat(pooledCond2);\r\n\t\t\t_.each (pooledData, function (value) {//pool to one array\r\n\t\t\t\tvar AnVar = value;\r\n\t\t\t\td = AnVar-avg;\r\n\t\t\t\tx2 += d*d;\r\n\r\n\t\t\t});\r\n\t\t\tp.variance = x2/(pooledData.length-1);\r\n\t\t},\r\n\r\n/*  Function: Void diffAll.\r\n\tInput: compute object.\r\n\tOutput: diff variabel.\r\n\tDescription: Loop over the pacels and set diff variable\r\n\tthat stores the diffrance between the averages of conditions.\r\n\r\n\r\n\t\tdiffAll: function(compute){\r\n\t\t\tconsole.log('starting diffAll');\r\n\t\t\t_.each (parcelMng.parcelArray, function (value,index) {\r\n\t\t\t\tparcelMng.diffParcel(value,compute);\r\n\t\t\t});\r\n\r\n\t\t},\r\n\r\n/*  Function: Void diffParcel.\r\n\tInput: compute object, parcel.\r\n\tOutput: setting avgCon1 and avgCon2\r\n\tDescription: Set average for condition 1 trials and for condition 2 trials in the parcel.\r\n\r\n\r\n\t\tdiffParcel: function(p,compute){\r\n\t\t\tconsole.log('starting diffParcel');\r\n\t\t\tp.diff = p.avgCon1 - p.avgCon2;\r\n\t\t\tconsole.log('finished diff parcel: '+p.name);\r\n\t\t\tconsole.log('diff: '+p.diff);\r\n\t\t\tconsole.log('--------------------');\r\n\r\n\t\t},\r\n\r\n/*  Function: Void scoreAll.\r\n\tInput: compute object.\r\n\tOutput: score variable in scoreData object\r\n\tDescription: Average the scores from all parcels set score in scoreData object.\r\n\r\n*/\r\n\t\tscoreAll: function(compute){\r\n\t\t\tvar dAvg = 0;\r\n\t\t\t_.each (parcelMng.parcelArray, function (value) {\r\n\t\t\t\tparcelMng.scoreParcel(value,compute);\r\n\t\t\t\tdAvg +=  value.score;\r\n\r\n\t\t\t});\r\n\t\t\tvar score = (dAvg/(parcelMng.parcelArray.length));\r\n\t\t\tparcelMng.scoreData.score = score.toFixed(2);\r\n\r\n\t\t},\r\n\r\n/*  Function: Void scoreParcel.\r\n\tInput: compute object, parcel.\r\n\tOutput: score variable in parcel\r\n\tDescription: Calculate the score for the parcel.\r\n\r\n*/\r\n\t\tscoreParcel: function(p){\r\n\t//\t\tconsole.log('starting scoreParcel');\r\n\t\t\tvar sd = Math.sqrt(p.variance);\r\n\t\t\tif (sd === 0){\r\n\t\t\t\tparcelMng.scoreData.errorMessage = msgMan.getMessage(\"notEnough\");\r\n\t\t\t\tp.score = p.diff;\r\n\t\t\t} else {\r\n\t\t\t\tp.score = p.diff/sd;\r\n\t\t\t}\r\n\t\t\t// console.log('finished score parcel: '+p.name);\r\n\t\t\t// console.log('score: '+p.score);\r\n\t\t\t// console.log('--------------------');\r\n\r\n\t\t},\r\n\r\n/*  Function: Void simulateOldCode.\r\n\tInput:\r\n\tOutput:\r\n\tDescription: For debug seimulate old scorer.\r\n\r\n*/\r\n\t\t//for QA purposes only!!\r\n\t\tsimulateOldCode: function(compute){\r\n\r\n\t\t\t//require\r\n\t\t\tvar results = [];\r\n\t\t\tvar rb = [2,3,5,6];\r\n\t\t\tvar cond1 = compute.cond1VarValues;\r\n\t\t\tvar cond2 = compute.cond2VarValues;\r\n\t\t\tvar condVar = compute.condVar;\r\n\t\t\tvar ErrorVar = compute.ErrorVar;\r\n\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\r\n\t\t\tvar parcelA = parcelMng.parcelArray[0];\r\n\t\t\tvar parcelB = parcelMng.parcelArray[1];\r\n\t\t\tvar trialsA = parcelA.trialIData;\r\n\t\t\tvar trialsB = parcelB.trialIData;\r\n\r\n\r\n\t\t\t\t//console.log('cond1 diff: ' + diff1.length );\r\n\r\n\t\t\t_.each (trialsA, function (value) {\r\n\t\t\t\tvar data = value.data;\r\n\t\t\t\tvar dataCond = data[condVar];\r\n\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\r\n\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\r\n\t\t\t\t//var diff1 = ( _(data[condVar]).difference(cond1) );//block 2\r\n\t\t\t\t//var diff2 = ( _(data[condVar]).difference(cond2) );//block 5\r\n\t\t\t\tvar trial = {};\r\n\t\t\t\tif (diff1){\r\n\t\t\t\t\ttrial.block = rb[0];\r\n\t\t\t\t\ttrial.lat = value[AnalyzedVar];\r\n\t\t\t\t\ttrial.err = data[ErrorVar];\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (diff2){\r\n\t\t\t\t\t\ttrial.block = rb[2];\r\n\t\t\t\t\t\ttrial.lat = value[AnalyzedVar];\r\n\t\t\t\t\t\ttrial.err = data[ErrorVar];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tresults.push(trial);\r\n\r\n\t\t\t});\r\n\t\t\t_.each (trialsB, function (value) {\r\n\t\t\t\tvar data = value.data;\r\n\t\t\t\tvar dataCond = data[condVar];\r\n\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\r\n\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\r\n\t\t\t\t//var diff1 = ( _(data[condVar]).difference(cond1) );//block 3\r\n\t\t\t\t//var diff2 = ( _(data[condVar]).difference(cond2) );//block 6\r\n\t\t\t\tvar trial = {};\r\n\t\t\t\tif (diff1){\r\n\t\t\t\t\ttrial.block = rb[1];\r\n\t\t\t\t\ttrial.lat = value[AnalyzedVar];\r\n\t\t\t\t\ttrial.err = data[ErrorVar];\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (diff2){\r\n\t\t\t\t\ttrial.block = rb[3];\r\n\t\t\t\t\ttrial.lat = value[AnalyzedVar];\r\n\t\t\t\t\ttrial.err = data[ErrorVar];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tresults.push(trial);\r\n\r\n\t\t\t});\r\n\r\n\r\n\r\n\t\t\tvar score = parcelMng.scoreTask(results,rb);\r\n\t\t\treturn score;\r\n\r\n\t\t}\r\n\t});\r\n\r\n\treturn parcelMng;\r\n\r\n});\n","define('extensions/dscore/Scorer',['jquery','underscore','./computeD','./msgMan','./parcelMng'],function($,_,computeData,msgMan,parcelMng){\r\n\twindow.console || (window.console = {log: $.noop, error: $.noop});\r\n\tvar Scorer = {};\r\n\r\n//comment\r\n\r\n\t$.extend(Scorer, {\r\n\r\n/*  Function: Void addSettings.\r\n\tInput: settings object.\r\n\tOutput: set the settings in computeD  object or msgMan according to input\r\n\tDescription: Settings for computeD or msgMan\r\n\r\n*/\r\n\t\taddSettings: function(type,Obj){\r\n\r\n\t\t\tif (type ==\"compute\"){\r\n\t\t\t\tcomputeData.setComputeObject(Obj);\r\n\t\t\t}else{\r\n\t\t\t\tif (type ==\"message\") {\r\n\t\t\t\t\tmsgMan.setMsgObject(Obj);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n/*  Function: Void init.\r\n\tInput: none.\r\n\tOutput: none\r\n\tDescription: make sure console.log is safe among all browsers.\r\n\r\n*/\r\n\t\tinit: function(){\r\n\t\t\t// js hint thinks that console is read only - and its correct except where it doesn't exist...  this is how we tell it to ignore these lines\r\n\t\t\t/* jshint -W020 */\r\n\t\t\t!!window.console || (console = {});\r\n\t\t\tconsole.log || (console.log = function(){});\r\n\t\t\t/* jshint +W020 */\r\n\t\t},\r\n\r\n/*  Function: Void computeD.\r\n\tInput: none.\r\n\tOutput: final score.\r\n\tDescription: Calculate the score returns an object that hold\r\n\tthe score an an error msg.\r\n\r\n*/\r\n\t\tcomputeD: function(){\r\n\r\n\t\t\tScorer.init();\r\n\t\t\tcomputeData.setDataArray();\r\n\t\t\t// console.log('started computeD');\r\n\t\t\t// console.log(computeData);\r\n\t\t\t// console.log(msgMan);\r\n\t\t\tparcelMng.Init(computeData);\r\n\t\t\tparcelMng.avgAll(computeData);\r\n\t\t\t//parcelMng.diffAll(computeData);\r\n\t\t\tparcelMng.varianceAll(computeData);\r\n\t\t\tparcelMng.scoreAll(computeData);\r\n\t\t\tvar scoreObj = parcelMng.scoreData;\r\n\t\t\tvar scoreData = {};\r\n\t\t\tif (scoreObj.errorMessage === undefined || scoreObj.errorMessage === null){\r\n\t\t\t\t\tscoreData.FBMsg = Scorer.getFBMsg(scoreObj.score);\r\n\t\t\t\t\tscoreData.DScore = scoreObj.score;\r\n\t\t\t}else{\r\n\t\t\t\t\tscoreData.FBMsg = scoreObj.errorMessage;\r\n\t\t\t\t\tscoreData.DScore = \"\";\r\n\t\t\t}\r\n\r\n\t\t//\tconsole.log('the score from new scoree is: '+scoreObj.score );\r\n\t\t\t//var oldScore = parcelMng.simulateOldCode(computeData);//for testing only\r\n\t\t\t//console.log('the score from old scoree is: '+oldScore );\r\n\r\n\t\t\treturn scoreData;\r\n\r\n\r\n\t\t},\r\n\r\n\r\n\t\tgetInfo: function(){\r\n\t\t\t//return computeData;\r\n\t\t},\r\n\r\n/*\r\n\tFunction: Void postToServer.\r\n\tInput: score, a message a key to be used.\r\n\tOutput: Ajax send to server.\r\n\tDescription: post to server the score and the message.\r\n*/\r\n\r\n\t\tpostToServer: function(score,msg,scoreKey,msgKey){\r\n\t\t\tvar postSettings = computeData.postSettings || {};\r\n\t\t\tvar url = postSettings.url;\r\n\r\n\t\t\tif (!scoreKey) {\r\n\t\t\t\tscoreKey = postSettings.score;\r\n\t\t\t}\r\n\t\t\tif (!msgKey) {\r\n\t\t\t\tmsgKey = postSettings.msg;\r\n\t\t\t}\r\n\t\t\tvar data = {};\r\n\t\t\tdata[scoreKey] = score;\r\n\t\t\tdata[msgKey] = msg;\r\n\r\n\t\t\treturn $.post(url,JSON.stringify(data));\r\n\t\t},\r\n\r\n\t\tdynamicPost: function(data){\r\n\t\t\tvar postSettings = computeData.postSettings || {};\r\n\t\t\tvar url = postSettings.url;\r\n\t\t\treturn $.post(url,JSON.stringify(data));\r\n\t\t},\r\n\r\n\t\t// get message according to user input\r\n\t\tgetFBMsg: function(DScore){\r\n\t\t\tvar msg = msgMan.getScoreMsg(DScore);\r\n\t\t\treturn msg;\r\n\t\t}\r\n\r\n\t});\r\n\treturn Scorer;\r\n});\n"]}